package actions

import (
	"github.com/h3rby7/reman/models"
	"fmt"
	"github.com/gobuffalo/buffalo"
	"github.com/gobuffalo/pop"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// This file is generated by Buffalo. It offers a basic structure for
// adding, editing and deleting a page. If your model is more
// complex or you need more than the basic implementation you need to
// edit this file.

// Following naming logic is implemented in Buffalo:
// Model: Singular (Event)
// DB Table: Plural (events)
// Resource: Plural (Events)
// Path: Plural (/events)
// View Template Folder: Plural (/templates/events/)

// EventsResource is the resource for the Event model
type EventsResource struct {
	buffalo.Resource
}

type Slot struct {
	Start           string
	NeedsToBeStable bool
}

// List gets all upcoming Events.
func (v EventsResource) ListUpcoming(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	events := &models.Events{}

	q := tx.Select()

	// Retrieve all Events from the DB
	if err := q.Where("events.end_date > now()").All(events); err != nil {
		return err
	}
	c.Set("events", events)
	c.Set("slots", getSlots(*events))

	return c.Render(200, r.HTML("events/upcoming"))
}

// Slots of 15 minutes
// Within the next 12h
func getSlots(events models.Events) []Slot {
	const timeSlotLengthInMin, foreCastInHours = 15, 24
	now := time.Now().UTC()
	// Go to the last 00, 15, 30, 45 minute mark
	now = now.Add(time.Duration(-(now.Minute() % timeSlotLengthInMin)) * time.Minute)
	slots := make([]Slot, foreCastInHours*60/timeSlotLengthInMin)
	for i, _ := range slots {
		then := now.Add(time.Duration(i*timeSlotLengthInMin) * time.Minute)
		slots[i] = Slot{
			Start:           fmt.Sprintf("%.2d:%.2d", then.Hour(), then.Minute()),
			NeedsToBeStable: timeRequiresStability(then, time.Duration(timeSlotLengthInMin), events),
		}
	}
	return slots
}

func timeRequiresStability(t time.Time, duration time.Duration, events models.Events) bool {
	blockStart, blockEnd := t, t.Add(duration)
	for _, v := range events {
		if v.EndDate.After(blockStart) && v.StartDate.Before(blockEnd) {
			return true
		}
	}
	return false
}

// List gets all Events. This function is mapped to the path
// GET /events
func (v EventsResource) List(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	events := &models.Events{}

	// Paginate results. Params "page" and "per_page" control pagination.
	// Default values are "page=1" and "per_page=20".
	q := tx.PaginateFromParams(c.Params())

	// Retrieve all Events from the DB
	if err := q.All(events); err != nil {
		return err
	}

	// Add the paginator to the context so it can be used in the template.
	c.Set("pagination", q.Paginator)

	return c.Render(200, r.Auto(c, events))
}

/* DEFAULT RESOURCE FUNCTIONALITY BELOW */

// Show gets the data for one Event. This function is mapped to
// the path GET /events/{event_id}
func (v EventsResource) Show(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Allocate an empty Event
	event := &models.Event{}

	// To find the Event the parameter event_id is used.
	if err := tx.Find(event, c.Param("event_id")); err != nil {
		return c.Error(404, err)
	}

	return c.Render(200, r.Auto(c, event))
}

// New renders the form for creating a new Event.
// This function is mapped to the path GET /events/new
func (v EventsResource) New(c buffalo.Context) error {
	setDateContexts(c, time.Now().UTC(), time.Now().UTC().Add(1*time.Hour))
	return c.Render(200, r.Auto(c, &models.Event{}))
}

// Create adds a Event to the DB. This function is mapped to the
// path POST /events
func (v EventsResource) Create(c buffalo.Context) error {
	// Allocate an empty Event
	event := &models.Event{}

	// Bind event to the html form elements
	if err := c.Bind(event); err != nil {
		return err
	}

	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	event.StartDate = combineTimeAndDate(event.StartDate, "startTime", c.Request().Form)
	event.EndDate = combineTimeAndDate(event.EndDate, "endTime", c.Request().Form)

	// Validate the data from the html form
	verrs, err := tx.ValidateAndCreate(event)
	if err != nil {
		return err
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the new.html template that the user can
		// correct the input.
		return c.Render(422, r.Auto(c, event))
	}

	// If there are no errors set a success message
	c.Flash().Add("success", T.Translate(c, "event.created.success"))
	// and redirect to the events index page
	return c.Render(201, r.Auto(c, event))
}

// Edit renders a edit form for a Event. This function is
// mapped to the path GET /events/{event_id}/edit
func (v EventsResource) Edit(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Allocate an empty Event
	event := &models.Event{}

	if err := tx.Find(event, c.Param("event_id")); err != nil {
		return c.Error(404, err)
	}

	setDateContexts(c, event.StartDate, event.EndDate)
	return c.Render(200, r.Auto(c, event))
}

// Update changes a Event in the DB. This function is mapped to
// the path PUT /events/{event_id}
func (v EventsResource) Update(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Allocate an empty Event
	event := &models.Event{}

	if err := tx.Find(event, c.Param("event_id")); err != nil {
		return c.Error(404, err)
	}

	// Bind Event to the html form elements
	if err := c.Bind(event); err != nil {
		return err
	}

	event.StartDate = combineTimeAndDate(event.StartDate, "startTime", c.Request().Form)
	event.EndDate = combineTimeAndDate(event.EndDate, "endTime", c.Request().Form)

	verrs, err := tx.ValidateAndUpdate(event)
	if err != nil {
		return err
	}

	if verrs.HasAny() {
		// Make the errors available inside the html template
		c.Set("errors", verrs)

		// Render again the edit.html template that the user can
		// correct the input.
		return c.Render(422, r.Auto(c, event))
	}

	// If there are no errors set a success message
	c.Flash().Add("success", T.Translate(c, "event.updated.success"))
	// and redirect to the events index page
	return c.Render(200, r.Auto(c, event))
}

// Destroy deletes a Event from the DB. This function is mapped
// to the path DELETE /events/{event_id}
func (v EventsResource) Destroy(c buffalo.Context) error {
	// Get the DB connection from the context
	tx, ok := c.Value("tx").(*pop.Connection)
	if !ok {
		return fmt.Errorf("no transaction found")
	}

	// Allocate an empty Event
	event := &models.Event{}

	// To find the Event the parameter event_id is used.
	if err := tx.Find(event, c.Param("event_id")); err != nil {
		return c.Error(404, err)
	}

	if err := tx.Destroy(event); err != nil {
		return err
	}

	// If there are no errors set a flash message
	c.Flash().Add("success", T.Translate(c, "event.destroyed.success"))
	// Redirect to the events index page
	return c.Render(200, r.Auto(c, event))
}

func setDateContexts(c buffalo.Context, startDate time.Time, endDate time.Time) {
	c.Set("startDate", startDate.Format("2006-01-02"))
	c.Set("endDate", endDate.Format("2006-01-02"))
	c.Set("startTime", fmt.Sprintf("%.2d:%.2d", startDate.Hour(), startDate.Minute()))
	c.Set("endTime", fmt.Sprintf("%.2d:%.2d", endDate.Hour(), endDate.Minute()))
}

func combineTimeAndDate(date time.Time, formKey string, form url.Values) (result time.Time) {
	value := form.Get(formKey)
	if value == "" {
		return date
	}
	timeInForm := strings.Split(value, ":")
	hour, _ := strconv.Atoi(timeInForm[0])
	minute, _ := strconv.Atoi(timeInForm[1])
	return time.Date(date.Year(), date.Month(), date.Day(), hour, minute, 0, 0, date.Location())
}
